-- Optional: create a specific schema if you want
-- CREATE SCHEMA IF NOT EXISTS my_schema;

-- 1. products
CREATE TABLE IF NOT EXISTS products (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category text,
  unit text NOT NULL DEFAULT 'litre',
  selling_price numeric(12,2) NOT NULL,
  cost_price numeric(12,2) NOT NULL DEFAULT 0,
  min_stock int NOT NULL DEFAULT 0,
  track_expiry boolean NOT NULL DEFAULT false,
  expiry_days int,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- 2. purchases
CREATE TABLE IF NOT EXISTS purchases (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  price numeric(12,2) NOT NULL,
  total numeric(12,2) GENERATED ALWAYS AS (quantity * price) STORED NOT NULL,
  purchase_date date NOT NULL DEFAULT current_date,
  expiry_date date
);

-- 3. sales
CREATE TABLE IF NOT EXISTS sales (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  price numeric(12,2) NOT NULL,
  total numeric(12,2) GENERATED ALWAYS AS (quantity * price) STORED NOT NULL,
  sale_date date NOT NULL DEFAULT current_date
);

-- 4. expenses
CREATE TABLE IF NOT EXISTS expenses (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category text,
  amount numeric(12,2) NOT NULL,
  notes text,
  expense_date date NOT NULL DEFAULT current_date
);

-- 5. waste/returns
CREATE TABLE IF NOT EXISTS waste (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  reason text NOT NULL CHECK (reason IN ('expired', 'damaged', 'other')),
  cost_value numeric(12,2) NOT NULL,
  waste_date date NOT NULL DEFAULT current_date,
  notes text
);

-- 6. Indexes
CREATE INDEX IF NOT EXISTS idx_purchases_product ON purchases(product_id);
CREATE INDEX IF NOT EXISTS idx_sales_product ON sales(product_id);
CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(purchase_date);
CREATE INDEX IF NOT EXISTS idx_sales_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(expense_date);
CREATE INDEX IF NOT EXISTS idx_waste_product ON waste(product_id);
CREATE INDEX IF NOT EXISTS idx_waste_date ON waste(waste_date);
CREATE INDEX IF NOT EXISTS idx_purchases_expiry ON purchases(expiry_date);

-- 7. inventory (view)
DROP VIEW IF EXISTS inventory CASCADE;
CREATE OR REPLACE VIEW inventory AS
SELECT
  p.id,
  p.name,
  p.category,
  p.unit,
  p.cost_price,
  p.selling_price,
  p.min_stock,
  p.track_expiry,
  COALESCE(sales_tot.total_sold, 0) AS total_sold,
  COALESCE(purch_tot.total_purchased, 0) AS total_purchased,
  COALESCE(waste_tot.total_wasted, 0) AS total_wasted,
  (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) AS current_stock,
  (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) * p.cost_price AS stock_value,
  CASE WHEN (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) < p.min_stock THEN true ELSE false END AS is_low_stock
FROM products p
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_purchased FROM purchases GROUP BY product_id
) purch_tot ON purch_tot.product_id = p.id
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_sold FROM sales GROUP BY product_id
) sales_tot ON sales_tot.product_id = p.id
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_wasted FROM waste GROUP BY product_id
) waste_tot ON waste_tot.product_id = p.id;

-- 8. expiring_items (view) - shows items expiring within 7 days
DROP VIEW IF EXISTS expiring_items CASCADE;
CREATE OR REPLACE VIEW expiring_items AS
SELECT
  p.id,
  p.name,
  p.category,
  pu.expiry_date,
  pu.quantity,
  (pu.expiry_date - current_date) AS days_until_expiry
FROM purchases pu
JOIN products p ON p.id = pu.product_id
WHERE pu.expiry_date IS NOT NULL
  AND pu.expiry_date >= current_date
  AND pu.expiry_date <= current_date + INTERVAL '7 days'
ORDER BY pu.expiry_date;

-- 9. low_stock_items (view) - shows items below minimum stock
DROP VIEW IF EXISTS low_stock_items CASCADE;
CREATE OR REPLACE VIEW low_stock_items AS
SELECT
  i.id,
  i.name,
  i.category,
  i.current_stock,
  i.min_stock,
  i.unit
FROM inventory i
WHERE i.is_low_stock = true
ORDER BY i.current_stock;

-- 10. top_selling_products (view) - shows top selling products
DROP VIEW IF EXISTS top_selling_products CASCADE;
CREATE OR REPLACE VIEW top_selling_products AS
SELECT
  p.id,
  p.name,
  p.category,
  COALESCE(SUM(s.quantity), 0) AS total_quantity_sold,
  COALESCE(SUM(s.total), 0) AS total_revenue
FROM products p
LEFT JOIN sales s ON s.product_id = p.id
GROUP BY p.id, p.name, p.category
ORDER BY total_quantity_sold DESC;

-- 11. daily_report (view)
DROP VIEW IF EXISTS daily_report CASCADE;
CREATE OR REPLACE VIEW daily_report AS
SELECT
  current_date AS date,
  COALESCE((SELECT SUM(total) FROM sales WHERE sale_date = current_date), 0) AS total_sales,
  COALESCE((SELECT SUM(total) FROM purchases WHERE purchase_date = current_date), 0) AS total_purchases,
  COALESCE((SELECT SUM(amount) FROM expenses WHERE expense_date = current_date), 0) AS total_expenses,
  COALESCE((SELECT SUM(cost_value) FROM waste WHERE waste_date = current_date), 0) AS total_waste,
  (
    COALESCE((SELECT SUM(total) FROM sales WHERE sale_date = current_date), 0)
    - COALESCE((SELECT SUM(total) FROM purchases WHERE purchase_date = current_date), 0)
    - COALESCE((SELECT SUM(amount) FROM expenses WHERE expense_date = current_date), 0)
    - COALESCE((SELECT SUM(cost_value) FROM waste WHERE waste_date = current_date), 0)
  ) AS net;

-- 12. months calendar table (useful for reports)
CREATE TABLE IF NOT EXISTS calendar_months (
  month_start date PRIMARY KEY
);

-- Helper function to populate months into calendar_months between two dates (inclusive)
CREATE OR REPLACE FUNCTION populate_calendar_months(start_date date, end_date date)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  cur date := date_trunc('month', start_date)::date;
  last date := date_trunc('month', end_date)::date;
BEGIN
  WHILE cur <= last LOOP
    INSERT INTO calendar_months (month_start)
    VALUES (cur)
    ON CONFLICT (month_start) DO NOTHING;
    cur := (cur + INTERVAL '1 month')::date;
  END LOOP;
END;
$$;

-- Example: populate last 24 months (uncomment to run)
-- SELECT populate_calendar_months(date_trunc('month', current_date) - INTERVAL '23 months', date_trunc('month', current_date));

-- 13. monthly_report (view) using calendar_months to include all months
DROP VIEW IF EXISTS monthly_report CASCADE;
CREATE OR REPLACE VIEW monthly_report AS
WITH sales_months AS (
  SELECT date_trunc('month', sale_date)::date AS month_start, COALESCE(SUM(total),0) AS total_sales
  FROM sales
  GROUP BY date_trunc('month', sale_date)
),
purchases_months AS (
  SELECT date_trunc('month', purchase_date)::date AS month_start, COALESCE(SUM(total),0) AS total_purchases
  FROM purchases
  GROUP BY date_trunc('month', purchase_date)
),
expenses_months AS (
  SELECT date_trunc('month', expense_date)::date AS month_start, COALESCE(SUM(amount),0) AS total_expenses
  FROM expenses
  GROUP BY date_trunc('month', expense_date)
),
waste_months AS (
  SELECT date_trunc('month', waste_date)::date AS month_start, COALESCE(SUM(cost_value),0) AS total_waste
  FROM waste
  GROUP BY date_trunc('month', waste_date)
)
SELECT
  cm.month_start AS month,
  COALESCE(sm.total_sales, 0) AS total_sales,
  COALESCE(pm.total_purchases, 0) AS total_purchases,
  COALESCE(em.total_expenses, 0) AS total_expenses,
  COALESCE(wm.total_waste, 0) AS total_waste,
  (COALESCE(sm.total_sales, 0) - COALESCE(pm.total_purchases, 0) - COALESCE(em.total_expenses, 0) - COALESCE(wm.total_waste, 0)) AS profit
FROM calendar_months cm
LEFT JOIN sales_months sm ON sm.month_start = cm.month_start
LEFT JOIN purchases_months pm ON pm.month_start = cm.month_start
LEFT JOIN expenses_months em ON em.month_start = cm.month_start
LEFT JOIN waste_months wm ON wm.month_start = cm.month_start
ORDER BY cm.month_start;
