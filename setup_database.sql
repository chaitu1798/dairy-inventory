-- Dairy Inventory - Consolidated Database Setup
-- This file contains the complete schema including tables, indexes, views, and security policies.

-- 1. EXTENSIONS & SETUP
-- (Supabase usually has these enabled by default, but good to have)
-- CREATE EXTENSION IF NOT EXISTS "uuid-ossp";

-- 2. TABLES

-- Products
CREATE TABLE IF NOT EXISTS products (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  category text,
  unit text NOT NULL DEFAULT 'litre',
  price numeric(12,2) NOT NULL, -- Renamed from selling_price for consistency
  cost_price numeric(12,2) NOT NULL DEFAULT 0,
  min_stock int NOT NULL DEFAULT 0,
  track_expiry boolean NOT NULL DEFAULT false,
  expiry_days int,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Customers
CREATE TABLE IF NOT EXISTS customers (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  name text NOT NULL,
  phone text,
  email text,
  address text,
  credit_limit numeric(12,2) DEFAULT 0,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Purchases
CREATE TABLE IF NOT EXISTS purchases (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  price numeric(12,2) NOT NULL,
  total numeric(12,2) GENERATED ALWAYS AS (quantity * price) STORED NOT NULL,
  purchase_date date NOT NULL DEFAULT current_date,
  expiry_date date
);

-- Sales
CREATE TABLE IF NOT EXISTS sales (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  customer_id bigint REFERENCES customers(id),
  quantity numeric(12,2) NOT NULL,
  price numeric(12,2) NOT NULL,
  total numeric(12,2) GENERATED ALWAYS AS (quantity * price) STORED NOT NULL,
  sale_date date NOT NULL DEFAULT current_date,
  invoice_number text UNIQUE,
  status text CHECK (status IN ('paid', 'pending', 'overdue')) DEFAULT 'paid',
  due_date date,
  amount_paid numeric(12,2) DEFAULT 0
);

-- Payments (for credit sales)
CREATE TABLE IF NOT EXISTS payments (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  sale_id bigint REFERENCES sales(id) ON DELETE CASCADE,
  amount numeric(12,2) NOT NULL,
  payment_date date NOT NULL DEFAULT current_date,
  payment_method text,
  notes text,
  created_at timestamptz NOT NULL DEFAULT now()
);

-- Expenses
CREATE TABLE IF NOT EXISTS expenses (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  category text,
  amount numeric(12,2) NOT NULL,
  notes text,
  expense_date date NOT NULL DEFAULT current_date
);

-- Waste/Returns
CREATE TABLE IF NOT EXISTS waste (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  reason text NOT NULL CHECK (reason IN ('expired', 'damaged', 'other')),
  cost_value numeric(12,2) NOT NULL,
  waste_date date NOT NULL DEFAULT current_date,
  notes text
);

-- Stock Logs (for auditing movements)
CREATE TABLE IF NOT EXISTS stock_logs (
  id bigint GENERATED BY DEFAULT AS IDENTITY PRIMARY KEY,
  product_id bigint NOT NULL REFERENCES products(id),
  quantity numeric(12,2) NOT NULL,
  action_type text NOT NULL CHECK (action_type IN ('IN', 'OUT')),
  image_url text,
  created_at timestamptz NOT NULL DEFAULT now(),
  updated_by text
);

-- Calendar Months (for reporting)
CREATE TABLE IF NOT EXISTS calendar_months (
  month_start date PRIMARY KEY
);

-- 3. INDEXES
CREATE INDEX IF NOT EXISTS idx_purchases_product ON purchases(product_id);
CREATE INDEX IF NOT EXISTS idx_sales_product ON sales(product_id);
CREATE INDEX IF NOT EXISTS idx_sales_customer ON sales(customer_id);
CREATE INDEX IF NOT EXISTS idx_purchases_date ON purchases(purchase_date);
CREATE INDEX IF NOT EXISTS idx_sales_date ON sales(sale_date);
CREATE INDEX IF NOT EXISTS idx_expenses_date ON expenses(expense_date);
CREATE INDEX IF NOT EXISTS idx_waste_product ON waste(product_id);
CREATE INDEX IF NOT EXISTS idx_waste_date ON waste(waste_date);
CREATE INDEX IF NOT EXISTS idx_payments_sale ON payments(sale_id);
CREATE INDEX IF NOT EXISTS idx_sales_status ON sales(status);

-- 4. VIEWS

-- Inventory View
DROP VIEW IF EXISTS inventory CASCADE;
CREATE OR REPLACE VIEW inventory AS
SELECT
  p.id,
  p.name,
  p.category,
  p.unit,
  p.cost_price,
  p.price, -- Renamed from selling_price
  p.min_stock,
  p.track_expiry,
  COALESCE(sales_tot.total_sold, 0) AS total_sold,
  COALESCE(purch_tot.total_purchased, 0) AS total_purchased,
  COALESCE(waste_tot.total_wasted, 0) AS total_wasted,
  (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) AS current_stock,
  -- Valuation using cost_price
  (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) * p.cost_price AS stock_value,
  CASE WHEN (COALESCE(purch_tot.total_purchased, 0) - COALESCE(sales_tot.total_sold, 0) - COALESCE(waste_tot.total_wasted, 0)) < p.min_stock THEN true ELSE false END AS is_low_stock
FROM products p
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_purchased FROM purchases GROUP BY product_id
) purch_tot ON purch_tot.product_id = p.id
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_sold FROM sales GROUP BY product_id
) sales_tot ON sales_tot.product_id = p.id
LEFT JOIN (
  SELECT product_id, SUM(quantity) AS total_wasted FROM waste GROUP BY product_id
) waste_tot ON waste_tot.product_id = p.id;

-- Expiring Items View
DROP VIEW IF EXISTS expiring_items CASCADE;
CREATE OR REPLACE VIEW expiring_items AS
SELECT
  p.id,
  p.name,
  p.category,
  pu.expiry_date,
  pu.quantity,
  (pu.expiry_date - current_date) AS days_until_expiry
FROM purchases pu
JOIN products p ON p.id = pu.product_id
WHERE pu.expiry_date IS NOT NULL
  AND pu.expiry_date >= current_date
  AND pu.expiry_date <= current_date + INTERVAL '7 days'
ORDER BY pu.expiry_date;

-- Low Stock View
DROP VIEW IF EXISTS low_stock_items CASCADE;
CREATE OR REPLACE VIEW low_stock_items AS
SELECT
  i.id,
  i.name,
  i.category,
  i.current_stock,
  i.min_stock,
  i.unit
FROM inventory i
WHERE i.is_low_stock = true
ORDER BY i.current_stock;

-- Top Selling View
DROP VIEW IF EXISTS top_selling_products CASCADE;
CREATE OR REPLACE VIEW top_selling_products AS
SELECT
  p.id,
  p.name,
  p.category,
  COALESCE(SUM(s.quantity), 0) AS total_quantity_sold,
  COALESCE(SUM(s.total), 0) AS total_revenue
FROM products p
LEFT JOIN sales s ON s.product_id = p.id
GROUP BY p.id, p.name, p.category
ORDER BY total_quantity_sold DESC;

-- Daily Report View
DROP VIEW IF EXISTS daily_report CASCADE;
CREATE OR REPLACE VIEW daily_report AS
SELECT
  current_date AS date,
  COALESCE((SELECT SUM(total) FROM sales WHERE sale_date = current_date), 0) AS total_sales,
  COALESCE((SELECT SUM(total) FROM purchases WHERE purchase_date = current_date), 0) AS total_purchases,
  COALESCE((SELECT SUM(amount) FROM expenses WHERE expense_date = current_date), 0) AS total_expenses,
  COALESCE((SELECT SUM(cost_value) FROM waste WHERE waste_date = current_date), 0) AS total_waste,
  (
    COALESCE((SELECT SUM(total) FROM sales WHERE sale_date = current_date), 0)
    - COALESCE((SELECT SUM(total) FROM purchases WHERE purchase_date = current_date), 0)
    - COALESCE((SELECT SUM(amount) FROM expenses WHERE expense_date = current_date), 0)
    - COALESCE((SELECT SUM(cost_value) FROM waste WHERE waste_date = current_date), 0)
  ) AS net;

-- Monthly Report View
DROP VIEW IF EXISTS monthly_report CASCADE;
CREATE OR REPLACE VIEW monthly_report AS
WITH sales_months AS (
  SELECT date_trunc('month', sale_date)::date AS month_start, COALESCE(SUM(total),0) AS total_sales
  FROM sales
  GROUP BY date_trunc('month', sale_date)
),
purchases_months AS (
  SELECT date_trunc('month', purchase_date)::date AS month_start, COALESCE(SUM(total),0) AS total_purchases
  FROM purchases
  GROUP BY date_trunc('month', purchase_date)
),
expenses_months AS (
  SELECT date_trunc('month', expense_date)::date AS month_start, COALESCE(SUM(amount),0) AS total_expenses
  FROM expenses
  GROUP BY date_trunc('month', expense_date)
),
waste_months AS (
  SELECT date_trunc('month', waste_date)::date AS month_start, COALESCE(SUM(cost_value),0) AS total_waste
  FROM waste
  GROUP BY date_trunc('month', waste_date)
)
SELECT
  cm.month_start AS month,
  COALESCE(sm.total_sales, 0) AS total_sales,
  COALESCE(pm.total_purchases, 0) AS total_purchases,
  COALESCE(em.total_expenses, 0) AS total_expenses,
  COALESCE(wm.total_waste, 0) AS total_waste,
  (COALESCE(sm.total_sales, 0) - COALESCE(pm.total_purchases, 0) - COALESCE(em.total_expenses, 0) - COALESCE(wm.total_waste, 0)) AS profit
FROM calendar_months cm
LEFT JOIN sales_months sm ON sm.month_start = cm.month_start
LEFT JOIN purchases_months pm ON pm.month_start = cm.month_start
LEFT JOIN expenses_months em ON em.month_start = cm.month_start
LEFT JOIN waste_months wm ON wm.month_start = cm.month_start
ORDER BY cm.month_start;

-- 5. FUNCTIONS

-- Populate Calendar Months
CREATE OR REPLACE FUNCTION populate_calendar_months(start_date date, end_date date)
RETURNS void
LANGUAGE plpgsql
AS $$
DECLARE
  cur date := date_trunc('month', start_date)::date;
  last date := date_trunc('month', end_date)::date;
BEGIN
  WHILE cur <= last LOOP
    INSERT INTO calendar_months (month_start)
    VALUES (cur)
    ON CONFLICT (month_start) DO NOTHING;
    cur := (cur + INTERVAL '1 month')::date;
  END LOOP;
END;
$$;

-- 6. SECURITY (RLS Policies)

-- Enable RLS on all tables
ALTER TABLE products ENABLE ROW LEVEL SECURITY;
ALTER TABLE purchases ENABLE ROW LEVEL SECURITY;
ALTER TABLE customers ENABLE ROW LEVEL SECURITY;
ALTER TABLE sales ENABLE ROW LEVEL SECURITY;
ALTER TABLE payments ENABLE ROW LEVEL SECURITY;
ALTER TABLE expenses ENABLE ROW LEVEL SECURITY;
ALTER TABLE waste ENABLE ROW LEVEL SECURITY;
ALTER TABLE stock_logs ENABLE ROW LEVEL SECURITY;

-- Create "Allow All" policies for authenticated users
-- Products
CREATE POLICY "Enable access for authenticated users" ON products FOR ALL USING (auth.role() = 'authenticated');
-- Purchases
CREATE POLICY "Enable access for authenticated users" ON purchases FOR ALL USING (auth.role() = 'authenticated');
-- Customers
CREATE POLICY "Enable access for authenticated users" ON customers FOR ALL USING (auth.role() = 'authenticated');
-- Sales
CREATE POLICY "Enable access for authenticated users" ON sales FOR ALL USING (auth.role() = 'authenticated');
-- Payments
CREATE POLICY "Enable access for authenticated users" ON payments FOR ALL USING (auth.role() = 'authenticated');
-- Expenses
CREATE POLICY "Enable access for authenticated users" ON expenses FOR ALL USING (auth.role() = 'authenticated');
-- Waste
CREATE POLICY "Enable access for authenticated users" ON waste FOR ALL USING (auth.role() = 'authenticated');
-- Stock Logs
CREATE POLICY "Enable access for authenticated users" ON stock_logs FOR ALL USING (auth.role() = 'authenticated');
